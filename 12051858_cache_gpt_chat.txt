é˜¶æ®µ 0ï¼šç¡®è®¤è¡¨ç¤º & é…ç½®ï¼ˆç°åœ¨å…¶å®å·²ç»å®Œæˆäº†ä¸€åŠï¼‰

ç›®æ ‡ï¼šæŠŠâ€œæ¨¡å‹çœ¼é‡Œçœ‹åˆ°çš„ä¸œè¥¿â€æè¿°æ¸…æ¥šï¼Œé¿å…åé¢æ¯ä¸€æ­¥éƒ½çŒœã€‚

æˆ‘ä»¬å·²ç»çŸ¥é“ï¼š

å®æœº qpos çš„æ„é€ æ–¹å¼ï¼š

tcp = state.actual_TCP_pose  # [x, y, z, rx, ry, rz]
left_arm  = tcp
right_arm = tcp
left_g = 0.0
right_g = 0.0
qpos = np.concatenate([left_arm, [left_g], right_arm, [right_g]])  # (14,)


å›¾åƒï¼šRealSense å½©è‰²å›¾åƒï¼Œresize åˆ° (640,480)ï¼Œè½¬æˆ (3,H,W) float32ï¼Œé™¤ä»¥ 255 å˜æˆ [0,1]ï¼›

ACT çš„ get_action(obs) æœŸæœ›çš„ obs ç»“æ„æ˜¯ï¼š

obs = {
    "qpos": qpos_14d,            # numpy, shape (14,)
    "head_cam": img0_chw_float,
    "left_cam": img1_chw_float,
    "right_cam": img2_chw_float,
}



ï¼ˆçŸ­æœŸå¦‚æœä½ åªæœ‰ 1 ä¸ªç›¸æœºï¼Œå°±å…ˆæŠŠåŒä¸€å¼ å›¾å¤åˆ¶æˆä¸‰ä¸ªé”®çš„å€¼ã€‚ï¼‰

ä½ ç°åœ¨åšçš„ï¼š è¿™ä¸€æ­¥æˆ‘ä»¬ç®—æ˜¯å·²ç»â€œè®¾è®¡å®Œâ€ï¼Œåé¢åªéœ€è¦ç…§è¿™ä¸ªçº¦å®šå†™ä»£ç ã€‚

é˜¶æ®µ 1ï¼šåªåšâ€œæ¨¡å‹åŠ è½½ + å‡æ•°æ®å‰å‘â€å°è„šæœ¬

ç›®æ ‡ï¼š ä¸è¿æœºå™¨äººã€ä¸è¿ç›¸æœºï¼Œå…ˆè¯æ˜ï¼š

ACT æ¨¡å‹èƒ½è¢«æ­£å¸¸åŠ è½½ï¼›

get_action(obs) æ¥å£èƒ½è·‘é€šï¼›

è¾“å‡ºçš„ action å½¢çŠ¶æ˜¯ (1,14)ï¼Œæ•°å€¼ä¸ä¼šæ˜¯ nan/infã€‚

å­åŠŸèƒ½ï¼š

å†™ä¸€ä¸ªå‡½æ•°ï¼š

def load_act_from_ckpt(ckpt_dir) -> ACT:
    # æ„é€  args_override, Dummy RoboTwin_Config, è¿”å› ACT å®ä¾‹


å†™ä¸€ä¸ªå° mainï¼š

policy = load_act_from_ckpt(CKPT_DIR)

dummy_obs = {
    "qpos": np.zeros(14, dtype=np.float32),
    "head_cam": np.zeros((3, 480, 640), dtype=np.float32),
    "left_cam": np.zeros((3, 480, 640), dtype=np.float32),
    "right_cam": np.zeros((3, 480, 640), dtype=np.float32),
}

action = policy.get_action(dummy_obs)
print(action.shape, action)


å¦‚ä½•éªŒè¯ï¼š

èƒ½è·‘å®Œä¸æŠ¥é”™ï¼›

action æ˜¯ numpy arrayï¼Œshape å¤§æ¦‚ (1,14)ï¼Œå…ƒç´ æ˜¯æœ‰é™æ•°ã€‚

è¿™ä¸€é˜¶æ®µæˆ‘ä»¬åªå…³å¿ƒ â€œACT è¿™å—ç –â€ è‡ªå·±æ²¡é—®é¢˜ã€‚

é˜¶æ®µ 2ï¼šä»ä¸€ä¸ª HDF5 episode é‡Œé‡å»º obs â†’ ä¸¢ç»™ ACT

ç›®æ ‡ï¼š ä¸è¿çœŸæœºï¼Œä½†ç”¨ä½ å·²ç»è½¬å¥½çš„æŸä¸ª episode0.hdf5ï¼š

è¯»å‡ºé‡Œé¢çš„ joint_action/left_arm ç­‰ï¼›

æŒ‰ process_data_real.py çš„é‚£å¥—é€»è¾‘ï¼Œæ„é€ çœŸå®çš„ qpos åºåˆ—å’Œå›¾åƒåºåˆ—ï¼›

å¯¹å…¶ä¸­ä¸€å¸§æ„é€  obsï¼Œæ‰”ç»™é˜¶æ®µ 1 çš„ policy.get_actionï¼›

ç¡®è®¤æ•´ä¸ªé“¾è·¯å®Œå…¨å¯¹é½è®­ç»ƒæ—¶çš„åˆ†å¸ƒã€‚

å­åŠŸèƒ½ï¼š

å†™ä¸€ä¸ªå°å‡½æ•°ï¼š

def load_one_step_from_hdf5(path, t=0):
    # è¿”å› qpos_t, image_t_chw, ä»¥åŠprintä¸€äº›è°ƒè¯•ä¿¡æ¯


åœ¨ main é‡Œï¼š

policy = load_act_from_ckpt(...)
qpos, img = load_one_step_from_hdf5(episode_path, t=10)

obs = {
    "qpos": qpos,
    "head_cam": img,
    "left_cam": img,
    "right_cam": img,
}
action = policy.get_action(obs)
print("qpos:", qpos)
print("action:", action)


å¦‚ä½•éªŒè¯ï¼š

æ•´ä¸ªè„šæœ¬è·‘é€šæ— é”™ï¼›

qpos å’Œ action æ•°å€¼çœ‹èµ·æ¥åœ¨åŒä¸€ä¸ªé‡çº§ï¼Œä¸ä¼šçˆ†åˆ°å‡ ç™¾å‡ åƒï¼›

ä½ å¯ä»¥é¡ºæ‰‹æŸ¥çœ‹è¿™ä¸ª episode çš„ debug/tcp_used.npyï¼Œç¡®è®¤ï¼š
qpos çš„å‰ 6 ç»´å¤§è‡´å°±æ˜¯é‚£ä¸€æ—¶åˆ»çš„ TCP poseã€‚

é˜¶æ®µ 1 + 2 åšå®Œï¼Œä½ å°±æœ‰äº†â€œACT åœ¨ç¦»çº¿æ•°æ®ä¸Šçš„å‰å‘æµ‹è¯•â€ï¼Œå¿ƒé‡Œä¼šå¾ˆè¸å®ã€‚

é˜¶æ®µ 3ï¼šçº¯çº¿ä¸Šè§‚æµ‹æ„é€ ï¼ˆRTDE + RealSenseï¼‰ï¼Œä¸ç¢°æ¨¡å‹ã€ä¸åŠ¨æœºå™¨äºº

ç›®æ ‡ï¼š è¿ä¸Š UR5e å’Œ RealSenseï¼Œåªåšä¸¤ä»¶äº‹ï¼š

æ¯ 0.1 ç§’è¯»ä¸€æ¬¡ actual_TCP_poseï¼ŒæŒ‰æˆ‘ä»¬çš„çº¦å®šæ‹¼æˆ qposï¼›

åŒæ—¶æŠ“ä¸€å¸§ RealSense å½©è‰²å›¾ï¼ŒæŠŠå®ƒè½¬æˆ (3,H,W) float32ï¼›

å®æ—¶æ‰“å° qpos çš„å‰ 6 ç»´ã€æ˜¾ç¤ºå›¾åƒçª—å£ï¼Œç¡®è®¤æ•°æ®è´¨é‡ã€‚

å­åŠŸèƒ½ï¼š

ç”¨ä½ ç°æœ‰çš„ rtde_collect_2_csv_func.py / rtde_init_test.pyï¼ŒæŠ½å‡ºä¸€ä¸ªï¼š

def get_current_tcp_from_rtde(con) -> np.ndarray:  # shape (6,)


ç”¨ä½ ç°æœ‰çš„ realsense_collect_2_folder_func.pyï¼ŒæŠ½å‡ºä¸€ä¸ªï¼š

def get_current_color_frame(pipeline) -> np.ndarray:  # HxWx3 uint8


å†™ä¸€ä¸ªå°è„šæœ¬ï¼š

while True:
    tcp = get_current_tcp_from_rtde(...)
    color = get_current_color_frame(...)
    qpos = build_qpos_from_tcp(tcp)   # 14 ç»´
    img_chw = preprocess_image(color) # 3xHxW float32

    print("tcp:", tcp)
    cv2.imshow("color", color)
    if cv2.waitKey(1) == ord('q'):
        break


å¦‚ä½•éªŒè¯ï¼š

æ¯ç§’æ‰“å°çš„ tcp è¿ç»­ã€ç¨³å®šï¼›

å›¾åƒçª—å£æ˜¾ç¤ºæ­£å¸¸ï¼›

ä¸ crashï¼Œä¸ä¸¢å¸§åˆ°ç¦»è°±ã€‚

é˜¶æ®µ 3 åšå®Œï¼Œæˆ‘ä»¬å°±æœ‰äº†ä¸€ä¸ªçœŸå®ä¸–ç•Œç‰ˆçš„ obs ç”Ÿæˆå™¨ã€‚

é˜¶æ®µ 4ï¼šæŠŠé˜¶æ®µ 1 + 3 æ‹¼èµ·æ¥ï¼šå®æ—¶æ¨ç†ï¼Œä½†ä¸æ§åˆ¶ UR5

ç›®æ ‡ï¼š è¿ UR5 + ç›¸æœº + æ¨¡å‹ï¼Œæ¯ 0.1s åšä¸€æ¬¡ï¼š

RTDE tcp â†’ qpos â†’ ACT.get_action â†’ target qpos(14) â†’ å–å‰6ç»´å½“ target_tcpï¼Œ
åªæ‰“å°å½“å‰ TCP å’Œç›®æ ‡ TCP çš„å·®å€¼ï¼Œä¸å‘æ§åˆ¶å‘½ä»¤ã€‚

å­åŠŸèƒ½ï¼š

åœ¨é˜¶æ®µ 3 çš„å¾ªç¯é‡Œï¼ŒåŠ ä¸Šæ¨¡å‹éƒ¨åˆ†ï¼š

policy = load_act_from_ckpt(...)

while True:
    tcp = get_current_tcp(...)
    color = get_current_color(...)
    qpos = build_qpos_from_tcp(tcp)
    img = preprocess_image(color)

    obs = {
        "qpos": qpos,
        "head_cam": img,
        "left_cam": img,
        "right_cam": img,
    }
    action = policy.get_action(obs)   # (1,14)
    target_qpos = action[0]
    target_tcp = target_qpos[:6]

    delta = target_tcp - tcp
    print("tcp:", tcp)
    print("target_tcp:", target_tcp)
    print("|delta|:", np.linalg.norm(delta))


å¦‚ä½•éªŒè¯ï¼š

èƒ½é•¿æœŸè·‘ä¸æŠ¥é”™ï¼›

delta çš„å¤§å°å¤§è‡´åœ¨ä¸€ä¸ªâ€œè‚‰çœ¼çœ‹ä¸Šå»åˆç†â€çš„èŒƒå›´ï¼Œæ¯”å¦‚å‡ æ¯«ç±³/å‡ åº¦ï¼Œè€Œä¸æ˜¯çªç„¶é£™åˆ° 0.5m / 3 radã€‚

è¿™ä¸€é˜¶æ®µæ˜¯ å®æœºæ¨ç†ä½†â€œåªçœ‹ä¸åŠ¨â€ï¼Œæœ€å®‰å…¨ï¼Œä¹Ÿèƒ½å¸®ä½ ç›´è§‰ç†è§£æ¨¡å‹å­¦åˆ°çš„ä¸œè¥¿ã€‚

é˜¶æ®µ 5ï¼šåŠ  UR æ§åˆ¶ï¼ˆç¬¬ä¸€ç‰ˆå…ˆç”¨ socketï¼‰ï¼Œå†è€ƒè™‘ RTDE æ§åˆ¶

ç›®æ ‡ï¼š åœ¨é˜¶æ®µ 4 çš„åŸºç¡€ä¸Šï¼ŒåŠ ä¸€ä¸ªéå¸¸ä¿å®ˆçš„æ§åˆ¶å±‚ï¼š

å¯¹ delta_tcp åŠ ä¸€ä¸ª per-step çš„æœ€å¤§æ­¥é•¿é™åˆ¶ï¼ˆæ¯”å¦‚ 1â€“2mmã€0.01radï¼‰ï¼›

ç”¨ä½ ç°æœ‰çš„ socket æ¥å£æ„é€ ä¸€ä¸ª movel(p[...]) å°æ­¥æŒ‡ä»¤ï¼›

çœŸæœºæ”¾åœ¨ç©ºä¸­ã€å‘¨å›´æ¸…ç©ºï¼Œåšæå°å¹…åº¦ç¼“æ…¢è¿åŠ¨ã€‚

å­åŠŸèƒ½ï¼š

å°è£…ä¸€ä¸ªæ§åˆ¶ç±»ï¼ˆä¸ºä»¥å RTDE æ§åˆ¶åšå‡†å¤‡ï¼‰ï¼š

class URController:
    def __init__(self, mode="socket"):
        ...

    def move_tcp_delta(self, delta_tcp):
        # é™å¹… + å‘é€ movel


åœ¨é˜¶æ®µ 4 çš„å¾ªç¯é‡Œæ›¿æ¢æ‰“å°é€»è¾‘ï¼š

delta = target_tcp - tcp
delta = clip_delta(delta, max_step=0.01)
controller.move_tcp_delta(delta)


å¦‚ä½•éªŒè¯ï¼š

æœºå™¨äººæ¯æ­¥ç§»åŠ¨éå¸¸å°ã€éå¸¸ç¨³ï¼Œä¸ä¼šä¹±é£ï¼›

ä½ å¯ä»¥éšæ—¶åœæ‰è„šæœ¬ï¼Œæœºå™¨äººåœä½ä¸åŠ¨ï¼›

ç¡®è®¤ OK åï¼Œå†æ…¢æ…¢è°ƒå¤§ max_stepã€‚

è‡³äº RTDE æ§åˆ¶ï¼š

å¯ä»¥ä½œä¸º é˜¶æ®µ 6ï¼ˆç‹¬ç«‹å°é¡¹ç›®ï¼‰ï¼š

å®‰è£… ur_rtde æˆ–ä½¿ç”¨å½“å‰ rtde åŒ…çš„æ§åˆ¶æ¥å£ï¼›

æŠŠ URController çš„å†…éƒ¨å®ç°ä» socket æ¢æˆ RTDEControlInterface.servoL/servoJï¼›

ä¸Šå±‚æ¨ç†è„šæœ¬ä¸éœ€è¦æ”¹ï¼Œåªæ˜¯æ§åˆ¶ backend æ¢äº†ã€‚

###########################################################

å¾ˆå¥½ï¼Œè¿™ä¸ª log éå¸¸å¹²å‡€ï¼Œè¯´æ˜æˆ‘ä»¬ç°åœ¨æœ‰ï¼š

* âœ… ACT æ¨¡å‹æˆåŠŸä»
  `/RoboTwin/policy/ACT/act_ckpt/act-torch_cube/simple-3/policy_best.ckpt` é‡ŒåŠ è½½ï¼›
* âœ… æˆåŠŸè¯»åˆ° `dataset_stats.pkl`ï¼›
* âœ… æˆåŠŸä» episode0.hdf5 é‡Œè§£å‡ºä¸€å¸§ï¼š

  * `qpos_np shape = (14,)`ï¼ˆå°±æ˜¯ left_arm 6 + left_gripper 1 + right_arm 6 + right_gripper 1ï¼‰
  * `image shape = (480, 640, 3)`
* âœ… å‰å‘è¾“å‡º `a_hat.shape = [1, 50, 14]`ï¼Œå’Œè®­ç»ƒæ—¶ä¸€è‡´ã€‚

ä¹Ÿå°±æ˜¯è¯´ï¼š**â€œHDF5 â†’ å½’ä¸€åŒ– â†’ ACT å‰å‘â€ æ•´æ¡é“¾è·¯å·²ç»æ‰“é€šäº†**ã€‚ğŸ‰
æ¥ä¸‹æ¥å°±å¯ä»¥ä¸Š **Stage 3ï¼šRTDE + RealSense åœ¨çº¿å‰å‘ï¼ˆä¸æ§åˆ¶æœºæ¢°è‡‚ï¼‰**ã€‚

---

## ä¸‹ä¸€æ­¥è®¡åˆ’ï¼ˆStage 3ï¼šåœ¨çº¿æ¨ç†ä½†ä¸å‘å‘½ä»¤ï¼‰

æˆ‘ä»¬å…ˆåšä¸€ä¸ªã€Œåªè¯»ä¸æ§åˆ¶ã€çš„è„šæœ¬ï¼š

* æ¯ 0.1sï¼š

  1. ç”¨ RTDE è¯»å½“å‰ `actual_TCP_pose`ï¼›
  2. å’Œä½ åœ¨ `convert_2_hdf5_output_log.py` é‡Œä¸€æ¨¡ä¸€æ ·ï¼ŒæŠŠ TCP å †æˆ 14 ç»´ qposï¼š
     [
     qpos = [tcp, 0, tcp, 0]
     ]
  3. ç”¨ RealSense è¯»ä¸€å¸§å½©è‰²å›¾ï¼›
  4. åšå’Œ Stage2 ä¸€æ ·çš„å½’ä¸€åŒ–ã€æ‹¼ image tensorï¼›
  5. å–‚ç»™ ACTï¼Œæ‰“å°ä¸€è¡Œè¾“å‡ºï¼ˆæ¯”å¦‚å‰ 5 ä¸ªå…³èŠ‚çš„ actionï¼‰ï¼›
  6. æ˜¾ç¤ºå½“å‰ç›¸æœºç”»é¢ï¼ŒæŒ‰ `q` é€€å‡ºã€‚

**è¿™ä¸ªé˜¶æ®µå®Œå…¨ä¸å‘æ§åˆ¶å‘½ä»¤ç»™æœºå™¨äºº**ï¼Œåªåšã€Œæ„ŸçŸ¥ â†’ æ¨¡å‹ã€ï¼Œè§‚å¯Ÿè¾“å‡ºæ˜¯å¦ç¨³å®šã€åˆç†ã€‚

---

## å…·ä½“è„šæœ¬ï¼ˆreal_eval_stage3_online_no_ctrl.pyï¼‰

åœ¨ VSCode é‡Œæ–°å»ºæ–‡ä»¶ï¼š

`RoboTwin/policy/ACT/real_eval_stage3_online_no_ctrl.py`

æŠŠä¸‹é¢æ•´æ®µä»£ç ç²˜è¿›å»ï¼Œä¿å­˜å³å¯ï¼š

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Stage 3: RTDE + RealSense åœ¨çº¿å‰å‘ï¼Œä½†ä¸æ§åˆ¶æœºæ¢°è‡‚
- æ¯ 1/CTRL_HZ ç§’ï¼š
  1) RTDE è¯» actual_TCP_pose
  2) æ„é€  qpos = [tcp, 0, tcp, 0] (14 ç»´)
  3) RealSense è¯»ä¸€å¸§å½©è‰²å›¾
  4) å½’ä¸€åŒ– + æ‰“åŒ…æˆ tensor
  5) å–‚ç»™ ACTï¼Œæ‰“å°ä¸€è¡Œ action
  6) æŒ‰ 'q' é€€å‡º

å…ˆéªŒè¯ã€ŒçœŸæœºä¼ æ„Ÿ â†’ ACTã€è¿™æ¡é“¾è·¯æ˜¯å¦ç¨³å®šã€‚
"""

import os
import time
import pickle

import numpy as np
import cv2
import torch

# å¤ç”¨ Stage1 é‡Œçš„åŠ è½½å‡½æ•°å’Œå¸¸é‡
from real_eval_stage1_load_act import (
    load_act_from_ckpt,
    TASK_NAME,
    TASK_CONFIG,
    EXPERT_DATA_NUM,
)

# RTDE / RealSense å·¥å…·
from rtde_collect_2_csv_func import connect_rtde
from realsense_collect_2_folder_func import start_realsense_pipeline

print("[DEBUG] real_eval_stage3_online_no_ctrl.py imported")

# ========= æ ¹æ®ä½ çš„å®é™…æƒ…å†µæ”¹ä¸€ä¸‹ =========
ROBOT_HOST = "192.168.0.3"
ROBOT_PORT = 30004
CTRL_HZ = 10.0          # æ§åˆ¶é¢‘ç‡ï¼Œå’Œé‡‡é›†æ—¶å°½é‡ä¿æŒä¸€è‡´

COLOR_WIDTH = 640
COLOR_HEIGHT = 480
COLOR_FPS = 30
# =========================================


def load_stats():
    """
    ä» ckpt ç›®å½•è¯»å– dataset_stats.pklï¼Œ
    è¿”å› stats, pre_process, post_process
    """
    base_dir = os.path.dirname(os.path.abspath(__file__))
    ckpt_dir = os.path.join(
        base_dir,
        "act_ckpt",
        f"act-{TASK_NAME}",
        f"{TASK_CONFIG}-{EXPERT_DATA_NUM}",
    )
    stats_path = os.path.join(ckpt_dir, "dataset_stats.pkl")
    print(f"[INFO] Loading stats from: {stats_path}")

    with open(stats_path, "rb") as f:
        stats = pickle.load(f)

    def pre_process(qpos_np: np.ndarray) -> np.ndarray:
        return (qpos_np - stats["qpos_mean"]) / stats["qpos_std"]

    def post_process(action_np: np.ndarray) -> np.ndarray:
        return action_np * stats["action_std"] + stats["action_mean"]

    return stats, pre_process, post_process


def build_qpos_from_tcp(tcp: np.ndarray) -> np.ndarray:
    """
    å’Œ convert_2_hdf5_output_log.py å®Œå…¨ä¸€è‡´ï¼š
        right_arm = tcp
        left_arm = tcp
        right_gripper = 0
        left_gripper = 0

    tcp: shape (6,)
    è¿”å›: shape (14,)
    """
    tcp = tcp.astype(np.float32)
    left_arm = tcp
    right_arm = tcp
    left_gripper = np.array([0.0], dtype=np.float32)
    right_gripper = np.array([0.0], dtype=np.float32)
    qpos = np.concatenate([left_arm, left_gripper, right_arm, right_gripper], axis=0)
    return qpos


def build_image_tensor(color_image, camera_names, device):
    """
    æŠŠä¸€å¼  HxWx3 çš„å›¾åƒå¤åˆ¶æˆ len(camera_names) è·¯ï¼Œ
    è½¬æˆ (1, N_cam, 3, H, W) çš„ float32 tensorã€‚
    """
    H, W = 480, 640
    img = cv2.resize(color_image, (W, H))
    img = img.astype(np.float32) / 255.0

    imgs = []
    for _ in camera_names:
        imgs.append(img)
    imgs = np.stack(imgs, axis=0)               # (N_cam, H, W, 3)
    imgs = np.transpose(imgs, (0, 3, 1, 2))     # (N_cam, 3, H, W)

    image_tensor = torch.from_numpy(imgs).to(device).unsqueeze(0)   # (1, N_cam, 3, H, W)
    return image_tensor


def main():
    # 1) åŠ è½½ ACT + stats
    policy, camera_names, device = load_act_from_ckpt()
    stats, pre_process, post_process = load_stats()

    # 2) å»ºç«‹ RTDE è¿æ¥ & å¯åŠ¨ RealSense
    con = connect_rtde(
        robot_host=ROBOT_HOST,
        robot_port=ROBOT_PORT,
        frequency_hz=CTRL_HZ,
    )
    pipeline = start_realsense_pipeline(
        width=COLOR_WIDTH,
        height=COLOR_HEIGHT,
        fps=COLOR_FPS,
    )

    print("[REAL] Start online forward (no control). Press 'q' in window to stop.")

    next_step_time = time.time()
    step_idx = 0

    try:
        while True:
            # 2.1 è¯» RTDE
            state = con.receive()
            if state is None:
                print("[REAL] RTDE connection closed.")
                break

            tcp = np.array(state.actual_TCP_pose, dtype=np.float32)   # (6,)
            qpos_np = build_qpos_from_tcp(tcp)                         # (14,)
            qpos_norm = pre_process(qpos_np)
            qpos_tensor = torch.from_numpy(qpos_norm).float().to(device).unsqueeze(0)  # (1, 14)

            # 2.2 è¯»ç›¸æœº
            frames = pipeline.wait_for_frames()
            color_frame = frames.get_color_frame()
            if not color_frame:
                continue
            color_image = np.asanyarray(color_frame.get_data())
            cv2.imshow("RealSense Color (ACT online)", color_image)

            image_tensor = build_image_tensor(color_image, camera_names, device)

            # 2.3 å‰å‘ ACTï¼Œå–ç¬¬ 0 ä¸ª query çš„ action
            with torch.no_grad():
                a_hat = policy(qpos_tensor, image_tensor)             # (1, 50, 14)
                if isinstance(a_hat, torch.Tensor):
                    raw_action = a_hat[0, 0].cpu().numpy()           # (14,)
                else:
                    raw_action = a_hat[0][0].cpu().numpy()

            action_real = post_process(raw_action)                    # åå½’ä¸€åŒ–åçš„ 14 ç»´

            # åªæ‰“å°å‰å‡ ç»´ï¼Œé¿å…åˆ·å±
            print(
                f"[STEP {step_idx:04d}] tcp[0:3]={tcp[:3]}, "
                f"action_real[0:5]={action_real[:5]}"
            )
            step_idx += 1

            # 2.4 ç»´æŒ CTRL_HZ
            next_step_time += 1.0 / CTRL_HZ
            sleep_t = next_step_time - time.time()
            if sleep_t > 0:
                time.sleep(sleep_t)

            # 2.5 æŒ‰ 'q' é€€å‡º
            key = cv2.waitKey(1) & 0xFF
            if key == ord("q"):
                print("[REAL] Quit by user.")
                break

    finally:
        try:
            con.send_pause()
        except Exception:
            pass
        con.disconnect()
        pipeline.stop()
        cv2.destroyAllWindows()
        print("[REAL] Online forward finished, connections closed.")


if __name__ == "__main__":
    main()
```

---

## ä½¿ç”¨æ–¹å¼

åœ¨ç»ˆç«¯ï¼ˆä½ ç°åœ¨è¿™ä¸ªç¯å¢ƒï¼‰ï¼š

```bash
cd ~/UR5e_DataCollection
python RoboTwin/policy/ACT/real_eval_stage3_online_no_ctrl.py
```

å‰æï¼š

* æœºæ¢°è‡‚æ§åˆ¶ç®±å¼€æœºï¼ŒIP ä¸ºè„šæœ¬é‡Œçš„ `ROBOT_HOST`ï¼ˆå¦‚æœä¸å¯¹ï¼Œæ”¹æˆå®é™… IPï¼‰ï¼›
* Polyscope åˆ‡åˆ° **Remote Control**ï¼›
* RealSense æ’ä¸Šï¼Œèƒ½æ­£å¸¸ç”¨ `realsense-viewer` çœ‹åˆ°ç”»é¢ã€‚

è¿è¡Œåä½ åº”è¯¥çœ‹åˆ°ï¼š

* ç»ˆç«¯é‡Œä¸æ–­æ‰“å°ï¼š

  ```text
  [STEP 0000] tcp[0:3]=[...] action_real[0:5]=[...]
  [STEP 0001] ...
  ...
  ```

* å±å¹•ä¸Šå¼¹ä¸€ä¸ª RealSense çš„çª—å£ï¼Œå®æ—¶ç”»é¢ï¼ŒæŒ‰ `q` é€€å‡ºã€‚

---

### ä¸€æ—¦è¿™ä¸ªè„šæœ¬ç¨³å®šè¿è¡Œ

æˆ‘ä»¬å°±åªå‰©æœ€åä¸€æ­¥ï¼š

* åœ¨è¿™ä¸ªè„šæœ¬çš„åŸºç¡€ä¸Šï¼Œåœ¨ `print` é‚£ä¸€è¡Œä¸‹é¢æ¥ä¸€ä¸ªç®€å•çš„ **UR æ§åˆ¶æ¥å£**ï¼ˆæ¯”å¦‚æŠŠ action å‰ 6 ç»´å˜æˆä¸€ä¸ªå°æ­¥é•¿çš„ TCP deltaï¼Œç”¨ `movel` æˆ– RTDE çš„é€Ÿåº¦æ§åˆ¶æ–¹å¼å‘ç»™æœºå™¨äººï¼‰ã€‚

é‚£å°±æ˜¯ Stage 4ï¼Œæˆ‘ä»¬å¯ä»¥ç­‰ä½ ç¡®è®¤ Stage 3 è·‘é¡ºäº†å†ä¸€èµ·æ”¹ã€‚



