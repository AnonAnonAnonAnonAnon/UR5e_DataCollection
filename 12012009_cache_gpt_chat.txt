å¥½ï¼Œæ­å–œä½ å·²ç»æŠŠ **10Hz å®æœºæ•°æ® â†’ ACT è®­ç»ƒ** è·‘èµ·æ¥äº†ï¼Œè¿™ä¸€æ­¥éå¸¸å…³é”® ğŸ’ª
ç°åœ¨æˆ‘ä»¬åˆ†ä¸¤ä»¶äº‹ï¼š

1. å…ˆæŠŠ **RoboTwin åŸç”Ÿçš„ä»¿çœŸè¯„ä¼° eval.sh / eval_policy.py** è®²æ¸…æ¥šï¼›
2. å†ç»™ä½ ä¸€å¥— **â€œå°½é‡å°‘æ”¹ä»£ç â€çš„å®æœºæ¨ç†æ–¹æ¡ˆ**ï¼ˆä¸å»ç¡¬æ”¹ eval_policyï¼Œé‚£ä¸€å¥—æ˜¯ç»™ SAPIEN ä»¿çœŸç”¨çš„ï¼‰ã€‚

---

## ä¸€ã€RoboTwin åŸç”Ÿä»¿çœŸè¯„ä¼°é•¿ä»€ä¹ˆæ ·ï¼Ÿ

### 1.1 `eval.sh` åœ¨å¹²å˜›ï¼Ÿ

`policy/ACT/eval.sh`ï¼š

```bash
#!/bin/bash

policy_name=ACT
task_name=${1}
task_config=${2}
ckpt_setting=${3}
expert_data_num=${4}
seed=${5}
gpu_id=${6}

export CUDA_VISIBLE_DEVICES=${gpu_id}
echo -e "\033[33mgpu id (to use): ${gpu_id}\033[0m"

cd ../..

PYTHONWARNINGS=ignore::UserWarning \
python script/eval_policy.py --config policy/$policy_name/deploy_policy.yml \
    --overrides \
    --task_name ${task_name} \
    --task_config ${task_config} \
    --ckpt_setting ${ckpt_setting} \
    --ckpt_dir policy/ACT/act_ckpt/act-${task_name}/${ckpt_setting}-${expert_data_num} \
    --seed ${seed} \
    --temporal_agg true
```

å«ä¹‰ï¼š

* å…¥å£å‚æ•°ï¼š

  * `task_name`ï¼š**RoboTwin é‡Œçš„ä»»åŠ¡ ID**ï¼Œæ¯”å¦‚ `beat_block_hammer`ï¼›
  * `task_config`ï¼šè¯„ä¼°ç¯å¢ƒé…ç½®ï¼ˆéšæœºåŒ–ç­‰çº§ã€æ‘„åƒå¤´ã€èƒŒæ™¯ç­‰ï¼‰ï¼Œå¯¹åº” `task_config/*.yml`ï¼›
  * `ckpt_setting`ï¼šè®­ç»ƒæ—¶çš„æ•°æ®é…ç½®ï¼ˆæ¯”å¦‚ `demo_clean` / `demo_randomized`ï¼‰ï¼Œç”¨äºç¡®å®š ckpt è·¯å¾„ï¼›
  * `expert_data_num`ï¼šè®­ç»ƒç”¨çš„ demo æ•°ç›®ï¼Œç”¨äºæ‹¼ ckpt ç›®å½•åï¼›
  * `seed` / `gpu_id`ï¼šéšæœºç§å­ / GPU é€‰æ‹©ã€‚
* å®ƒæœ€ç»ˆè°ƒç”¨ï¼š

```bash
python script/eval_policy.py \
  --config policy/ACT/deploy_policy.yml \
  --overrides \
  --task_name ... \
  --task_config ... \
  --ckpt_setting ... \
  --ckpt_dir policy/ACT/act_ckpt/act-${task_name}/${ckpt_setting}-${expert_data_num} \
  --seed ... \
  --temporal_agg true
```

* `deploy_policy.yml` æ˜¯ä¸€ä¸ªåŸºç¡€é…ç½®æ–‡ä»¶ï¼Œ`--overrides` åé¢çš„é”®å€¼ä¼šè¦†ç›– yaml é‡Œçš„å­—æ®µï¼Œå¾—åˆ°æœ€ç»ˆçš„ `usr_args`ã€‚

---

### 1.2 `script/eval_policy.py` çš„ä¸»æµç¨‹

æ ¸å¿ƒç»“æ„ï¼š

```python
if __name__ == "__main__":
    from test_render import Sapien_TEST
    Sapien_TEST()

    usr_args = parse_args_and_config()
    main(usr_args)
```

#### â‘  è§£æé…ç½®

```python
def parse_args_and_config():
    parser = argparse.ArgumentParser()
    parser.add_argument("--config", type=str, required=True)
    parser.add_argument("--overrides", nargs=argparse.REMAINDER)
    args = parser.parse_args()

    with open(args.config, "r") as f:
        config = yaml.safe_load(f)

    # æŠŠ "--task_name torch_cube --seed 0 ..." è§£ææˆ dict è¦†ç›–è¿› config
    ...
    return config    # è®°ä½œ usr_args
```

ä½ åœ¨ `eval.sh` é‡Œä¼ çš„ `task_name / task_config / ckpt_dir / seed` éƒ½è¢«å¡è¿›äº† `usr_args`ã€‚

#### â‘¡ main(usr_args)ï¼šåˆ›å»ºä»¿çœŸç¯å¢ƒ + åŠ è½½ç­–ç•¥

```python
task_name = usr_args["task_name"]         # æ¯”å¦‚ "beat_block_hammer"
task_config = usr_args["task_config"]     # æ¯”å¦‚ "demo_clean"
ckpt_setting = usr_args["ckpt_setting"]   # æ¯”å¦‚ "demo_clean"
policy_name = usr_args["policy_name"]     # æ¥è‡ª deploy_policy.ymlï¼ŒæŒ‡å‘æŸä¸ª python æ¨¡å—
instruction_type = usr_args["instruction_type"]

get_model = eval_function_decorator(policy_name, "get_model")
```

* `policy_name` æ˜¯ä¸€ä¸ªæ¨¡å—è·¯å¾„ï¼Œæ¯”å¦‚ `"policy.ACT.deploy_policy"`ï¼ˆä¸¾ä¾‹ï¼‰ï¼Œ
  `eval_function_decorator(policy_name, "get_model")` ç­‰ä»·äºï¼š

```python
policy_model = importlib.import_module(policy_name)
get_model = policy_model.get_model
```

* ç„¶åè¯»å–ä»»åŠ¡é…ç½® yamlï¼š

```python
with open(f"./task_config/{task_config}.yml", "r") as f:
    args = yaml.load(...)

args['task_name'] = task_name
args["task_config"] = task_config
args["ckpt_setting"] = ckpt_setting
```

è¿™ä¸ª `task_config.yml` é‡Œå®šä¹‰äº†ï¼š

* domain randomizationï¼šæ¡Œé¢æ‚ç‰©ã€éšæœºèƒŒæ™¯/å…‰ç…§ã€ç›¸æœºæŠ–åŠ¨ï¼›
* camera ç±»å‹ï¼š`head_camera_type` / `wrist_camera_type`ï¼›
* embodimentï¼šåŒè‡‚æœºå™¨äººç”¨å“ªä¸ª URDFã€å…³èŠ‚åç­‰ã€‚

æ¥ç€ï¼š

```python
embodiment_type = args.get("embodiment")
_embodiment_config.yml é‡Œæ‰¾åˆ°å¯¹åº”æœºå™¨äººçš„è·¯å¾„
 -> left_robot_file / right_robot_file
 -> æ¯ä¸ªæœºå™¨äººçš„ config.yml å†³å®š arm å…³èŠ‚ç»´åº¦
...
args["left_embodiment_config"] = get_embodiment_config(args["left_robot_file"])
args["right_embodiment_config"] = get_embodiment_config(args["right_robot_file"])
usr_args["left_arm_dim"] = len(args["left_embodiment_config"]["arm_joints_name"][0])
usr_args["right_arm_dim"] = len(args["right_embodiment_config"]["arm_joints_name"][1])
```

ä¹Ÿå°±æ˜¯è¯´ï¼š**eval_policy.py åœ¨è¿™é‡Œå®Œæˆäº†â€œä»»åŠ¡ + æœºä½“ + ç›¸æœº + éšæœºåŒ–â€ä¸€æ•´å¥—ä»¿çœŸé…ç½®ã€‚**

ç„¶ååˆ›å»ºä»¿çœŸç¯å¢ƒï¼š

```python
TASK_ENV = class_decorator(args["task_name"])
# ç­‰ä»·äº envs.<task_name>.<task_name>()
```

ä¹Ÿå°±æ˜¯ä» `envs/beat_block_hammer.py` é‡ŒåŠ è½½ä»»åŠ¡ç±»ï¼Œå®ä¾‹åŒ–å‡ºä¸€ä¸ª SAPIEN ç¯å¢ƒã€‚

æœ€ååŠ è½½ç­–ç•¥ï¼š

```python
model = get_model(usr_args)   # ç”± policy/ACT/deploy_policy.py å®ç°
```

`get_model` é‡Œé€šå¸¸ä¼šï¼š

* è¯» ckpt è·¯å¾„ï¼›
* åˆ›å»º ACTPolicyï¼›
* åŠ è½½æƒé‡ï¼›
* å°è£…æˆä¸€ä¸ª â€œRoboTwin é£æ ¼â€çš„æ¥å£ï¼ˆå¸¦ `eval()` / `reset_model()` ç­‰ï¼‰ã€‚

#### â‘¢ eval_policyï¼šåœ¨ä»¿çœŸé‡Œåå¤ roll out

```python
st_seed = 100000 * (1 + seed)
suc_nums = []
test_num = 100
model = get_model(usr_args)

st_seed, suc_num = eval_policy(task_name, TASK_ENV, args, model, st_seed, test_num, ...)
```

`eval_policy(...)` ï¼š

1. **å…ˆç”¨â€œä¸“å®¶â€è·‘ä¸€é**ï¼Œç¡®ä¿è¿™ä¸€éšæœºç§å­ä¸‹çš„ç¯å¢ƒæ˜¯å¯è§£çš„ï¼š

   ```python
   TASK_ENV.setup_demo(now_ep_num=now_id, seed=now_seed, is_test=True, **args)
   episode_info = TASK_ENV.play_once()    # ä¸“å®¶æˆ–è§„åˆ’å™¨è·‘ä¸€é
   TASK_ENV.close_env()
   ```

   å¦‚æœå¤±è´¥ï¼Œå°±æ¢ä¸€ä¸ª seedï¼Œé¿å…è¯„ä¼°è½åœ¨â€œä»»åŠ¡æœ¬èº«ä¸å¯èƒ½â€çš„éšæœºé…ç½®ä¸Šã€‚

2. **ç”Ÿæˆè‡ªç„¶è¯­è¨€æŒ‡ä»¤**ï¼š

   ```python
   episode_info_list = [episode_info["info"]]
   results = generate_episode_descriptions(args["task_name"], episode_info_list, test_num)
   instruction = np.random.choice(results[0][instruction_type])
   TASK_ENV.set_instruction(instruction=instruction)
   ```

3. **å¯åŠ¨è§†é¢‘å½•åˆ¶ï¼ˆå¯é€‰ï¼‰**ï¼šç”¨ ffmpeg æŠŠ env æ¸²æŸ“å†™æˆ mp4ã€‚

4. **ç”¨ç­–ç•¥æ§åˆ¶ç¯å¢ƒ**ï¼š

   ```python
   eval_func = eval_function_decorator(policy_name, "eval")
   reset_func = eval_function_decorator(policy_name, "reset_model")

   succ = False
   reset_func(model)
   while TASK_ENV.take_action_cnt < TASK_ENV.step_lim:
       observation = TASK_ENV.get_obs()
       eval_func(TASK_ENV, model, observation)  # é‡Œé¢ä¼šè°ƒç”¨ ACT / OpenVLA ç­‰äº§ç”Ÿå‘½ä»¤å¹¶ env.step()
       if TASK_ENV.eval_success:
           succ = True
           break
   ```

5. ç»Ÿè®¡æˆåŠŸæ¬¡æ•°ã€å†™ `_result.txt`ã€ä¿å­˜è§†é¢‘å’Œæ—¥å¿—åˆ°ï¼š

   ```text
   eval_result/{task_name}/{policy_name}/{task_config}/{ckpt_setting}/{timestamp}/
   ```

> æ€»ç»“ï¼š
> `eval.sh + eval_policy.py` æ˜¯ **â€œRoboTwin é€šç”¨ä»¿çœŸè¯„ä¼°æ¡†æ¶â€**ï¼Œ
> æŠŠï¼šç¯å¢ƒ randomization + æŒ‡ä»¤ç”Ÿæˆ + è§†é¢‘å½•åˆ¶ + æˆåŠŸç‡ç»Ÿè®¡ éƒ½ç»Ÿä¸€å°è£…äº†ã€‚
> å®ƒå‡å®šä½ æœ‰ `envs.<task_name>` è¿™ä¸€æ•´å¥— SAPIEN ä»»åŠ¡å®ç°ã€‚

---

## äºŒã€ä¸ºä»€ä¹ˆä¸ç›´æ¥ç”¨è¿™å¥—ä»£ç åš UR5 å®æœºï¼Ÿ

å› ä¸ºè¿™å¥— eval pipeline æœ‰å‡ ä¸ªâ€œå¼ºä¾èµ–â€ï¼š

1. è¦æœ‰ `envs.<task_name>` è¿™ä¸ª **ä»¿çœŸç¯å¢ƒç±»**ï¼ˆåŸºäº SAPIENï¼‰ï¼š

   * æä¾› `setup_demo() / play_once() / get_obs() / step() / check_success()`ï¼›
   * æ¸²æŸ“å›¾åƒç»™ ffmpegï¼›
   * å’Œ RoboTwin çš„ randomization / camera é…ç½®è€¦åˆå¾—å¾ˆç´§ã€‚

2. `eval_func(TASK_ENV, model, observation)` é‡Œå‡è®¾ï¼š

   * `TASK_ENV` æ˜¯ä»¿çœŸ envï¼›
   * å®ƒå†…éƒ¨ç”¨ SAPIEN æ±‚è§£åŠ¨åŠ›å­¦ï¼Œè‡ªå·±è°ƒç”¨ `TASK_ENV.step(...)`ã€‚

3. `task_config.yml` ä¸­æœ‰å¤§é‡ä»¿çœŸä¸“ç”¨å‚æ•°ï¼ˆèƒŒæ™¯çº¹ç†ã€å…‰æºã€table heightã€camera pose éšæœºåŒ–ç­‰ï¼‰ï¼Œå¯¹å®æœº UR5 å®Œå…¨ä¸é€‚ç”¨ã€‚

å¦‚æœä½ è¦ç…§ç€è¿™å¥—æ¡†æ¶åšå®æœºè¯„ä¼°ï¼Œç­‰äºè¦ï¼š

* å†™ä¸€ä¸ª **UR5+RealSense ç‰ˆçš„ TASK_ENV**ï¼Œå®ç°ä¸Šé¢æ‰€æœ‰æ–¹æ³•ï¼›
* å†™å¥½ `get_obs()` è¿”å›çš„æ ¼å¼ä¸ä»¿çœŸä¸€è‡´ï¼›
* åœ¨ `eval_func` é‡Œè°ƒç”¨ RTDE å‘é€åŠ¨ä½œï¼Œè€Œä¸æ˜¯ä»¿çœŸ env.stepã€‚

è¿™åè€Œå·¥ç¨‹é‡æ›´å¤§ï¼Œä¸ç¬¦åˆä½ ç°åœ¨ â€œ**å°½é‡å°‘æ”¹åŠ¨**â€ çš„ç›®æ ‡ã€‚

---

## ä¸‰ã€æœ€å°æ”¹åŠ¨å®ç°â€œä¸€æ¬¡å®æœºæ¨ç†â€çš„æ¨èåšæ³•

**æ€è·¯ï¼šå®Œå…¨ç»•å¼€ `eval.sh` & `eval_policy.py`ï¼Œæ–°å†™ä¸€ä¸ªå°è„šæœ¬ï¼Œç›´æ¥ï¼š**

1. åŠ è½½ä½ åˆšè®­ç»ƒå¥½çš„ ACTï¼›
2. åŠ è½½ `dataset_stats.pkl` åšå½’ä¸€åŒ–ï¼›
3. åœ¨ä¸€ä¸ª while å¾ªç¯é‡Œï¼š

   * ä» UR5 RTDE è¯»å½“å‰ TCP poseï¼›
   * ä» RealSense è¯»ä¸€å¸§å›¾åƒï¼›
   * æ‹¼å‡ºå’Œè®­ç»ƒåŒåˆ†å¸ƒçš„ `(qpos, image)`ï¼›
   * è°ƒ ACT å¾—åˆ° `action`ï¼ˆ14ç»´ï¼‰ï¼›
   * æŠŠå®ƒæ˜ å°„å› â€œä¸‹ä¸€æ­¥ TCP poseâ€ï¼Œå‘é€ç»™ UR5ï¼›
   * é‡å¤ N æ­¥æˆ–æŒ‰é”®é€€å‡ºã€‚

### 3.1 ckpt åœ¨å“ªé‡Œï¼Ÿ

è®­ç»ƒæ—¶ä½ ç”¨çš„æ˜¯ï¼š

```bash
bash train.sh torch_cube simple 6 0 0
```

train.sh é‡Œï¼š

```bash
--task_name sim-${task_name}-${task_config}-${expert_data_num}
--ckpt_dir ./act_ckpt/act-${task_name}/${task_config}-${expert_data_num}
```

æ‰€ä»¥è¿™æ¬¡è®­ç»ƒçš„æƒé‡å’Œ stats åœ¨ï¼š

```text
policy/ACT/act_ckpt/act-torch_cube/simple-6/
    â”œâ”€â”€ policy_best.ckpt
    â”œâ”€â”€ policy_last.ckpt
    â”œâ”€â”€ policy_epoch_XXXX_seed_0.ckpt
    â””â”€â”€ dataset_stats.pkl
```

åé¢æˆ‘ä»¬å°±ç”¨è¿™ä¸ªç›®å½•ã€‚

---

### 3.2 æ–°å»ºä¸€ä¸ªè¶…ç®€åŒ–å®æœºæ¨ç†è„šæœ¬ï¼ˆå»ºè®®å« real_eval_torch_cube.pyï¼‰

æ”¾åˆ°ï¼š`/home/zhangw/UR5e_DataCollection/RoboTwin/policy/ACT/real_eval_torch_cube.py`

ä¸‹é¢æ˜¯ä¸€ä»½**éª¨æ¶ä»£ç **ï¼ˆå°½é‡å¤ç”¨äº† ACT è‡ªå·±çš„é€»è¾‘ï¼Œæ²¡ç¢° eval_policy.pyï¼‰ï¼š

> âš ï¸ æ³¨æ„ï¼šä¸‹é¢å…³äº **UR5 å‘é€åŠ¨ä½œ** çš„éƒ¨åˆ†æˆ‘ç”¨ `# TODO` æ ‡å‡ºæ¥äº†ï¼Œéœ€è¦ä½ ç”¨è‡ªå·±ç°æœ‰çš„æ§åˆ¶å‡½æ•°å¡«ä¸Šï¼Œä»¥å…ç›´æ¥æŠŠæœºæ¢°è‡‚æ’é£ã€‚å…ˆç”¨å° stepã€æ…¢é€Ÿæµ‹è¯•ã€‚

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
ç”¨åˆšåˆšè®­ç»ƒå¥½çš„ ACT åœ¨ UR5 + RealSense ä¸Šåšä¸€æ¬¡ç®€å•å®æœºæ¨ç†ï¼ˆ10Hzï¼‰
- æ¯ä¸ªå¾ªç¯ï¼š
  1. è¯»å–å½“å‰ TCP pose
  2. è¯»å–ç›¸æœºå›¾åƒ
  3. æ„é€  qpos + images å’Œè®­ç»ƒæ—¶ä¸€è‡´çš„æ ¼å¼
  4. å‰å‘ ACTï¼Œå–ç¬¬ä¸€ä¸ª action
  5. ç”¨ action çš„å‰ 6 ç»´ä½œä¸ºä¸‹ä¸€æ­¥çš„ TCP ç›®æ ‡ï¼ˆå¯ä»¥åŠ ä¸€ä¸ªç¼©æ”¾å› å­ï¼‰
"""

import os
import time

import numpy as np
import cv2
import torch
import pickle

from act_policy import ACTPolicy
from constants import SIM_TASK_CONFIGS

# ä½ ä¹‹å‰ç”¨çš„æ•°æ® key
TASK_KEY = "sim-torch_cube-simple-6"

# ckpt ç›®å½•
CKPT_DIR = "./act_ckpt/act-torch_cube/simple-6"

DEVICE = "cuda" if torch.cuda.is_available() else "cpu"

# ====== 1. åŠ è½½å·²è®­ç»ƒå¥½çš„ ACT + å½’ä¸€åŒ–ç»Ÿè®¡ ======

def load_act_policy():
    """
    è¿”å›ï¼š
      policy        : å·²ç» load_state_dict å¹¶è®¾ä¸º eval() çš„ ACTPolicy
      pre_process   : qpos å½’ä¸€åŒ–å‡½æ•°
      post_process  : action åå½’ä¸€åŒ–å‡½æ•°
      camera_names  : è®­ç»ƒæ—¶ç”¨åˆ°çš„ç›¸æœºåˆ—è¡¨
    """
    task_cfg = SIM_TASK_CONFIGS[TASK_KEY]
    camera_names = task_cfg["camera_names"]    # ["cam_high", "cam_right_wrist", "cam_left_wrist"]

    # å’Œ train.sh ä¸€è‡´çš„è¶…å‚
    policy_config = {
        "lr": 1e-5,
        "num_queries": 50,      # chunk_size
        "kl_weight": 10,
        "hidden_dim": 512,
        "dim_feedforward": 3200,
        "lr_backbone": 1e-5,
        "backbone": "resnet18",
        "enc_layers": 4,
        "dec_layers": 7,
        "nheads": 8,
        "camera_names": camera_names,
    }

    policy = ACTPolicy(policy_config)
    ckpt_path = os.path.join(CKPT_DIR, "policy_best.ckpt")
    state_dict = torch.load(ckpt_path, map_location=DEVICE)
    policy.load_state_dict(state_dict)
    policy.to(DEVICE)
    policy.eval()
    print(f"[ACT] Loaded policy from {ckpt_path}")

    # åŠ è½½ dataset_stats.pkl
    stats_path = os.path.join(CKPT_DIR, "dataset_stats.pkl")
    with open(stats_path, "rb") as f:
        stats = pickle.load(f)
    print(f"[ACT] Loaded stats from {stats_path}")

    def pre_process(qpos_np: np.ndarray) -> np.ndarray:
        return (qpos_np - stats["qpos_mean"]) / stats["qpos_std"]

    def post_process(action_np: np.ndarray) -> np.ndarray:
        return action_np * stats["action_std"] + stats["action_mean"]

    return policy, pre_process, post_process, camera_names


# ====== 2. æ„é€ å’Œè®­ç»ƒä¸€è‡´çš„ qpos + image æ ¼å¼ ======

def build_qpos_from_tcp(tcp_pose):
    """
    tcp_pose: shape (6,), [x, y, z, rx, ry, rz]
    è®­ç»ƒæ—¶æˆ‘ä»¬æŠŠ tcp å¤åˆ¶åˆ°äº† left_arm/right_armï¼Œå¹¶æŠŠä¸¤ä¸ª gripper è®¾ä¸º 0
    å¾—åˆ° 14 ç»´ï¼š
        [left_arm(6), left_gripper(1), right_arm(6), right_gripper(1)]
    """
    tcp_pose = np.asarray(tcp_pose, dtype=np.float32)
    left_arm = tcp_pose
    right_arm = tcp_pose
    left_gripper = np.array([0.0], dtype=np.float32)
    right_gripper = np.array([0.0], dtype=np.float32)
    state = np.concatenate([left_arm, left_gripper, right_arm, right_gripper], axis=0)  # (14,)
    return state


def build_image_tensor(color_image, camera_names):
    """
    color_image: H x W x 3 (uint8, BGR æˆ– RGB éƒ½é—®é¢˜ä¸å¤§ï¼Œè¿™é‡Œåªæ˜¯å–‚ç»™ CNN)
    ä¸ºäº†å¯¹é½è®­ç»ƒæ—¶çš„ 3 è·¯ç›¸æœºï¼Œè¿™é‡Œç²—æš´åœ°ï¼šæŠŠåŒä¸€å¼ å›¾å¤åˆ¶æˆ N_cam è·¯
    è¾“å‡º: torch.Tensor, shape (1, N_cam, 3, H, W)
    """
    # è®­ç»ƒæ—¶ resize åˆ° (640,480)ï¼Œè¿™é‡Œä¹Ÿå¯¹é½ä¸€ä¸‹
    img = cv2.resize(color_image, (640, 480))
    # OpenCV æ˜¯ BGRï¼Œè¿™é‡Œä¸å¼ºåˆ¶è½¬ï¼Œå½±å“ä¸å¤§ï¼›æƒ³ä¸¥è°¨å¯ä»¥ cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    img = img.astype(np.float32) / 255.0   # [0,1]

    imgs = []
    for _ in camera_names:
        imgs.append(img)   # N_cam åŒå›¾

    imgs = np.stack(imgs, axis=0)          # (N_cam, H, W, 3)
    imgs = np.transpose(imgs, (0, 3, 1, 2))# (N_cam, 3, H, W)
    imgs = torch.from_numpy(imgs).to(DEVICE).unsqueeze(0)  # (1, N_cam, 3, H, W)
    return imgs


# ====== 3. å’Œ UR5 / RealSense æ‰“é€š ======

def run_real_rollout():
    # 3.1 åŠ è½½ç­–ç•¥
    policy, pre_process, post_process, camera_names = load_act_policy()

    # 3.2 å»ºç«‹ RTDE / RealSense è¿æ¥ï¼ˆç›´æ¥å¤ç”¨ä½ å·²æœ‰çš„å‡½æ•°ï¼‰
    from rtde_collect_2_csv_func import connect_rtde
    from realsense_collect_2_folder_func import start_realsense_pipeline

    ROBOT_HOST = "192.168.0.3"
    ROBOT_PORT = 30004
    CTRL_HZ = 10.0         # æ¨ç†æ§åˆ¶é¢‘ç‡ï¼Œå’Œä½ é‡‡é›†æ—¶ä¸€è‡´

    con = connect_rtde(robot_host=ROBOT_HOST, robot_port=ROBOT_PORT, frequency_hz=CTRL_HZ)
    pipeline = start_realsense_pipeline(width=640, height=480, fps=30)

    print("[REAL] Start ACT control loop, press 'q' in window to stop.")

    try:
        next_step_time = time.time()
        step_idx = 0

        while True:
            # 1) è¯»å½“å‰æœºå™¨äºº TCP pose
            state = con.receive()
            if state is None:
                print("[REAL] RTDE connection closed.")
                break
            tcp = np.array(state.actual_TCP_pose, dtype=np.float32)  # (6,)

            # 2) è¯»å½“å‰ç›¸æœºå›¾åƒ
            frames = pipeline.wait_for_frames()
            color_frame = frames.get_color_frame()
            if not color_frame:
                continue
            color_image = np.asanyarray(color_frame.get_data())
            cv2.imshow("RealSense Color (ACT Control)", color_image)

            # 3) æ„é€  qpos + image tensor
            qpos = build_qpos_from_tcp(tcp)             # (14,)
            qpos_norm = pre_process(qpos)               # å½’ä¸€åŒ–
            qpos_tensor = torch.from_numpy(qpos_norm).float().to(DEVICE).unsqueeze(0)  # (1, 14)
            image_tensor = build_image_tensor(color_image, camera_names)               # (1, N_cam, 3, H, W)

            # 4) å‰å‘ ACTï¼Œå–ç¬¬ä¸€ä¸ªåŠ¨ä½œï¼ˆç®€å•ç‰ˆæœ¬ï¼šæ¯æ¬¡éƒ½é‡ç®—ï¼Œåªç”¨ a[0]ï¼‰
            with torch.no_grad():
                all_actions = policy(qpos_tensor, image_tensor)
                # all_actions: (1, num_queries, state_dim)ï¼Œå–ç¬¬ 0 ä¸ª time step
                raw_action = all_actions[:, 0]                  # (1, 14)
                raw_action = raw_action.squeeze(0).cpu().numpy()# (14,)
            action = post_process(raw_action)                   # åå½’ä¸€åŒ– -> çœŸå®å…³èŠ‚

            # 5) æŠŠ action æ˜ å°„å› â€œä¸‹ä¸€æ­¥ TCP poseâ€
            #    è¿™é‡Œæœ‰å¾ˆå¤šè®¾è®¡ç©ºé—´ï¼Œä¸ºäº†å®‰å…¨ï¼Œå…ˆåªç”¨ä¸€ä¸ªå°æ­¥é•¿çš„ delta
            target_full = action  # (14,)
            target_tcp = target_full[:6]  # åªæ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­

            # å»ºè®®å‰ªè£ deltaï¼Œé¿å…ä¸€æ¬¡èµ°å¤ªè¿œ
            delta_tcp = target_tcp - tcp
            max_step = 0.01  # æ¯æ­¥æœ€å¤š 1cm/0.01radï¼Œè‡ªå·±æŒ‰éœ€è°ƒå°
            step_norm = np.linalg.norm(delta_tcp)
            if step_norm > max_step:
                delta_tcp *= max_step / (step_norm + 1e-6)
            safe_target_tcp = tcp + delta_tcp

            print(f"[STEP {step_idx:04d}] tcp = {tcp}, target = {safe_target_tcp}")

            # TODO: åœ¨è¿™é‡Œè°ƒç”¨ä½ ç°æœ‰çš„ UR æ§åˆ¶æ¥å£ï¼ŒæŠŠ safe_target_tcp å‘ç»™ UR5
            # æ¯”å¦‚ï¼šmoveL_to_tcp(safe_target_tcp, t=0.1) æˆ– speedL(delta_tcp/dt, a, ...)

            step_idx += 1

            # é™åˆ¶æ§åˆ¶é¢‘ç‡ä¸º CTRL_HZ
            next_step_time += 1.0 / CTRL_HZ
            sleep_t = next_step_time - time.time()
            if sleep_t > 0:
                time.sleep(sleep_t)

            # æŒ‰ 'q' é€€å‡º
            key = cv2.waitKey(1) & 0xFF
            if key == ord('q'):
                print("[REAL] Quit by user.")
                break

    finally:
        try:
            con.send_pause()
        except Exception:
            pass
        con.disconnect()
        pipeline.stop()
        cv2.destroyAllWindows()
        print("[REAL] Rollout finished, connections closed.")


if __name__ == "__main__":
    run_real_rollout()
```

**ç‰¹ç‚¹ï¼š**

* æ²¡æœ‰æ”¹åŠ¨ä½ ç°æœ‰çš„è®­ç»ƒä»£ç ã€`eval.sh`ã€`eval_policy.py`ï¼›
* æ–°å¢äº†ä¸€ä¸ªè„šæœ¬ï¼Œé€»è¾‘éå¸¸ç›´æ¥ï¼š

  * åŠ è½½ ACT + statsï¼›
  * RTDE + RealSense å®æ—¶é‡‡æ ·ï¼›
  * å½’ä¸€åŒ– â†’ è¡Œä¸ºå‰å‘ â†’ åå½’ä¸€åŒ–ï¼›
  * æŠŠ action çš„å‰ 6 ç»´æŠ½å‡ºæ¥ä½œä¸º TCP çš„ deltaï¼ˆåŠ äº†å‰ªè£ä¿æŠ¤ï¼‰ï¼›
  * ä½ åªéœ€è¦åœ¨ `# TODO` ä½ç½®æ¥ä¸Šè‡ªå·±çš„ UR æ§åˆ¶å‡½æ•°å³å¯ã€‚

---

### 3.3 å®‰å…¨å»ºè®®ï¼ˆä¸€å®šè¦æ³¨æ„ï¼‰

1. **å…ˆä¸åŠ¨æœºæ¢°è‡‚ï¼Œå…ˆæ‰“ logï¼š**

   * å¯ä»¥å…ˆæŠŠ `TODO` çš„æ§åˆ¶éƒ¨åˆ†æ³¨é‡Šæ‰ï¼Œåªæ‰“å° `delta_tcp`ï¼›
   * çœ‹çœ‹æ¨¡å‹çš„è¾“å‡ºæ˜¯ä¸æ˜¯åˆç†ï¼ˆæ˜¯å¦å¤šæ•°æ—¶å€™æ˜¯å°æ­¥åç§»ï¼Œè€Œä¸æ˜¯ä¹±è·³ï¼‰ã€‚

2. **çœŸæœºæµ‹è¯•æ—¶ï¼š**

   * å¼€å§‹å…ˆæŠŠ `max_step` è®¾å¾—éå¸¸å°ï¼ˆæ¯”å¦‚ 2~3mm / 0.005radï¼‰ï¼›
   * æŠŠæœºå™¨äººæ‘†åœ¨ä¸€ä¸ªæ²¡æœ‰éšœç¢çš„é«˜å¤„ç©ºä¸­ä½å§¿ï¼Œåªçœ‹å®ƒå¾®è°ƒï¼›
   * ç¡®è®¤ä¸ä¼šå¤§å¹…ä¹±åŠ¨åï¼Œå†æ…¢æ…¢å¢å¤§æ­¥é•¿ã€‚

3. **ä¸€å¼€å§‹å¯ä»¥æ‰‹åŠ¨å•æ­¥æ‰§è¡Œï¼š**

   * æŠŠ `while True` æ”¹æˆåª run 1~2 æ­¥ï¼›
   * æ¯æ­¥æ‰§è¡Œå®Œåç­‰ä½ æŒ‰é”®ç»§ç»­ã€‚

---

## å››ã€å°ç»“

* **ä»¿çœŸè¯„ä¼°ï¼ˆeval.sh + eval_policy.pyï¼‰**ï¼š
  æ˜¯ RoboTwin ä¸º SAPIEN ç¯å¢ƒè®¾è®¡çš„ä¸€å¥—å¤§è€Œå…¨ pipelineï¼Œé€‚åˆç»Ÿä¸€è¯„æµ‹ 50 ä¸ª benchmark ä»»åŠ¡ï¼Œä¸é€‚åˆç›´æ¥æ‹¿æ¥è·‘ UR5 å®æœºã€‚

* **å®æœºæ¨ç†ï¼ˆä½ ç°åœ¨è¦çš„ï¼‰**ï¼š
  æ¨èå†™ä¸€ä¸ªç®€å•çš„ `real_eval_torch_cube.py`ï¼Œå®Œå…¨å¤ç”¨ ACT çš„ model + statsï¼Œåªæ”¹â€œç¯å¢ƒéƒ¨åˆ†â€ä¸ºï¼š

  > RTDE + RealSense â†’ æ„é€  qpos/image â†’ ACT â†’ æ§åˆ¶ UR5ã€‚

å¦‚æœä½ æ„¿æ„ï¼Œä¸‹ä¸€æ­¥ä½ å¯ä»¥ï¼š

1. æŠŠä¸Šé¢çš„è„šæœ¬å­˜æˆ `real_eval_torch_cube.py`ï¼›
2. å…ˆæ³¨é‡Šæ‰æ§åˆ¶éƒ¨åˆ†ï¼Œè®©å®ƒåªæ‰“å° `tcp` & `safe_target_tcp`ï¼›
3. è¿è¡Œä¸€æ¬¡çœ‹çœ‹è¾“å‡ºæ˜¯ä¸æ˜¯åˆç†ï¼Œç„¶åæˆ‘ä»¬å†ä¸€èµ·è®¨è®ºå¦‚ä½•æ›´ä¼˜é›…åœ°æŠŠ action æ˜ å°„ä¸º UR æŒ‡ä»¤ï¼ˆæ¯”å¦‚ç”¨ joint space è€Œä¸æ˜¯ TCPã€æˆ–è€…å¼•å…¥ç®€å•çš„ MPC ç­‰ï¼‰ã€‚


